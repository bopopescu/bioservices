# -*- python -*-
#
#  This file is part of bioservices software
#
#  Copyright (c) 2011-2013 - EBI-EMBL
#
#  File author(s): 
#      Thomas Cokelaer <cokelaer@ebi.ac.uk>
#      https://www.assembla.com/spaces/bioservices/team
#
#  Distributed under the GPLv3 License.
#  See accompanying file LICENSE.txt or copy at
#      http://www.gnu.org/licenses/gpl-3.0.html
#
#  website: https://www.assembla.com/spaces/bioservices/wiki
#  documentation: http://packages.python.org/bioservices
#
##############################################################################
#$Id$
"""This module provides a class :class:`~Kegg` that allows an easy access to all the
WDSL Kegg interface as well as additional methods to obtain statistics about the
Kegg database. See below for details about the functionalities available and the
tutorial/quickstart :ref:`kegg_tutorial`.


.. topic:: What is KEGG ?

    :URL: http://www.kegg.jp/
    :REST: http://www.kegg.jp/kegg/rest/keggapi.html
    :REST: http://www.genome.jp/kegg/rest/weblink.html
    :REST: http://www.genome.jp/kegg/rest/dbentry.html

    .. highlights::

        "KEGG is a database resource for understanding high-level functions and
        utilities of the biological system, such as the cell, the organism and the
        ecosystem, from molecular-level information, especially large-scale molecular
        datasets generated by genome sequencing and other high-throughput experimental
        technologies (See Release notes for new and updated features). "
        
        -- Kegg home page, Jan 2013



Some terminology 
--------------------

This list is taken from Kegg API page and slightly edited.


* organisms (**org**) are made of a three-letter (or four-letter) code (e.g., hsa
  stands for Human Sapiens) used in KEGG (see
  :meth:`~bioservices.kegg.Kegg.organisms`). 
* **db** is a database name used in GenomeNet service. See
  :meth:`~bioservices.kegg.Kegg.databases`
* **entry_id** is a unique identifier that is a combination of the database name
  and the identifier of an entry joined by a colon sign (e.g. 'embl:J00231'
  means an EMBL entry 'J00231').
  **entry_id** includes:

    * **genes_id**: identifier consisting of 'keggorg' and a gene name (e.g. 'eco:b0001' means an E. coli gene 'b0001').
    * **enzyme_id**: identifier consisting of database name 'ec' and an enzyme code used in KEGG/LIGAND ENZYME database. (e.g. 'ec:1.1.1.1' means an alcohol dehydrogenase enzyme)
    * **compound_id**: identifier consisting of database name 'cpd' and a
      compound number used in KEGG COMPOUND / LIGAND database (e.g. 'cpd:C00158'
      means a citric acid). Some compounds also have 'glycan_id' and
      both IDs are accepted and converted internally.
    * **drug_id**: identifier consisting of database name 'dr' and a compound
      number used in KEGG DRUG / LIGAND database (e.g. 'dr:D00201' means a
      tetracycline).
    * **glycan_id**: identifier consisting of database name 'gl' and a glycan
      number used in KEGG GLYCAN database (e.g. 'gl:G00050' means a
      Paragloboside). Some glycans also have 'compound_id' and both
      IDs are accepted and converted internally. see
      :attr:`~bioservices.kegg.Kegg.glycanIds` attribute.
    * **reaction_id**:  identifier consisting of database name 'rn' and a
      reaction number used in KEGG/REACTION (e.g. 'rn:R00959' is a reaction
      which catalyze cpd:C00103 into cpd:C00668).
    * **pathway_id**: identifier consisting of 'path' and a pathway number used
      in KEGG/PATHWAY. Pathway numbers prefixed by 'map' specify the reference
      pathway and pathways prefixed by the 'keggorg' specify pathways specific
      to the organism (e.g. 'path:map00020' means a reference pathway for the
      cytrate cycle and 'path:eco00020' means a same pathway of which E. coli
      genes are marked). See :attr:`~bioservices.kegg.Kegg.pathwayIds` attribute.
    * **motif_id** is a motif identifier consisting of motif database names
      ('ps' for prosite, 'bl' for blocks, 'pr' for prints, 'pd' for prodom, and
      'pf' for pfam) and a motif entry name. (e.g. 'pf:DnaJ' means a Pfam
      database entry 'DnaJ').
    * **ko_id**: identifier consisting of 'ko' and a ko number used in KEGG/KO.
      KO (KEGG Orthology) is an classification of orthologous genes defined by
      KEGG (e.g. 'ko:K02598' means a KO group for nitrite transporter NirC
      genes).
    * **ko_class_id**: identifier which is used to classify 'ko_id' hierarchically 
      (e.g. '01110' means a 'Carbohydrate Metabolism' class).
      `URL:http://www.genome.jp/dbget-bin/get_htext?KO`   




"""

"""


Database    Name    Abbrev  kid     Remark
KEGG PATHWAY    pathway     path    map number  
KEGG BRITE  brite   br  br number   
KEGG MODULE     module  md  M number    
KEGG DISEASE    disease     ds  H number    Japanese version: disease_ja ds_ja
KEGG DRUG   drug    dr  D number    Japanese version: drug_ja dr_ja
KEGG ENVIRON    environ     ev  E number    Japanese version: environ_ja ev_ja
KEGG ORTHOLOGY  orthology   ko  K number    
KEGG GENOME     genome  genome  T number    
KEGG GENOMES    genomes     gn  T number    Composite database: genome + egenome
+ mgenome
KEGG GENES  genes   -   -   Composite database: consisting of KEGG organisms
KEGG LIGAND     ligand  ligand  -   Composite database: compound + glycan +
reaction + rpair + rclass + enzyme
KEGG COMPOUND   compound    cpd     C number    Japanese version: compound_ja
cpd_ja
KEGG GLYCAN     glycan  gl  G number    
KEGG REACTION   reaction    rn  R number    
KEGG RPAIR  rpair   rp  RP number   
KEGG RCLASS     rclass  rc  RC number   
KEGG ENZYME     enzyme  ec  -   


Database entry

<dbentries> = <dbentry>1[+<dbentry>2...]
<dbentry> = <db:entry> | <kid> | <org:gene>

Each database entry is identified by:
db:entry
where
"db" is the database name or its abbreviation shown above and
"entry" is the entry name or the accession number that is uniquely assigned
within the database.
In reality "db" may be omitted, for the entry name called the KEGG object
identifier (kid) is unique across KEGG.
kid = database-dependent prefix + five-digit number
In the KEGG GENES database the db:entry combination must be specified. This is
more specifically written as:
org:gene
where
"org" is the three- or four-letter KEGG organism code or the T number genome
identifier and
"gene" is the gene identifier, usually locus_tag or ncbi GeneID, or the primary
gene name.


"""

from services import RESTService
import webbrowser
import copy


class Kegg(RESTService):
    """Interface to the `KEGG <http://www.genome.jp/kegg/pathway.html>`_ database

    ::

        import kegg
        k = kegg.Kegg()
        print k.get("hsa:7535")
        print len(k.pathways)
        k.organismIds


    """

    #: valida database 
    _valid_DB_base = ["module", "disease", "drug","environ", "ko", 
        "genome", "compound", "glycan", "reaction", "rpair", "rclass", 
        "enzyme"]

    _valid_databases_info = _valid_DB_base + ["pathway", "brite", "genes", "ligand", "genomes", "kegg"]
    _valid_databases_list = _valid_DB_base + ["pathway", "brite", "organism"]
    _valid_databases_find = _valid_DB_base + ["pathway", "genes", "ligand"] 
    _valid_databases_link = _valid_DB_base + ["pathway", "brite"] 


    def __init__(self, verbose=True):
        """.. rubric:: Constructor

        :param bool verbose:

        """
        super(Kegg, self).__init__(name="Kegg", url="http://rest.kegg.jp", verbose=verbose)
        self.easyXMLConversion = False
        self._organisms = None
        self._organisms_tnumbers = None
        self._organism = None
        self._pathway = None
        self._glycan = None
        self._compound = None
        self._ko = None
        self._enzyme = None
        self._reaction = None
        self._drug = None

        """      brite        70,811 entries
                 module      161,771 entries
                 disease       1,301 entries
                 environ         845 entries
                 orthology    16,300 entries
                 genome        2,444 entries
                 genes     9,947,623 entries
                 dgenes      335,886 entries
                 rpair        13,856 entries
                 rclass        2,773 entries
        """

    def isOrganism(self, data):
        if data in self.organismIds:
            return True
        if data in self.organisms_tnumbers:
            return True
        else:
            return False

    def _checkDB(self, database=None, mode=None):
        self.logging.info("checking database %s (mode=%s)" % (database, mode))
        isOrg = self.isOrganism(database)

        if mode == "info":
            if database not in Kegg._valid_databases_info and isOrg == False:
                self.logging.error("database or organism provided is not correct (mode=info)")
                raise
        elif mode == "list":
            if database not in Kegg._valid_databases_list and isOrg == False:
                self.logging.error("database provided is not correct (mode=list)")
                raise 
        elif mode == "find":
            if database not in Kegg._valid_databases_find and isOrg == False:
                self.logging.error("database provided is not correct (mode=find)")
                raise 
        elif mode == "link":
            if database not in Kegg._valid_databases_link and isOrg == False:
                self.logging.error("database provided is not correct (mode=link)")
                raise 

        else:
            raise ValueError("mode can be only info, list, ")

    def info(self, database="kegg"):
        """Displays the current statistics of a given database

        :param str database: can be one of: kegg (default), brite, module,
            disease, drug, environ, ko, genome, compound, glycan, reaction,
            rpair, rclass, enzyme, genomes, genes, ligand or any 
            :attr:`organismIds`. 

        ::

            from bioservices import Kegg
            k = Kegg()
            k.info("hsa") # human organism
            k.info("T01001") # same as above
            k.info("pathway")

        """
        url = self.url+"/"+"info"
        self._checkDB(database, mode="info")

        url = url + "/" + database
        res = self.request(url)
        return res

    def list(self, query, organism=None):
        """returns a list of entry identifiers and associated definition for a given database or a given set of database entries 

        :param str query: can be one of pathway, brite, module,
            disease, drug, environ, ko, genome, compound,
            glycan, reaction, rpair, rclass, enzyme, organism
            **or** an organism from the :attr:`organismIds` attribute **or** a valid
            dbentry (see below). If a dbentry query is provided, organism
            should not be used!
        :param str organism: a valid organism identifier that can be 
            provided. If so, database can be only "pathway" or "module"

        There are convenient aliases to some of the databases. For instance,
        organism database can also be retrieved as a list from the
        :attr:`organismIds` attribute. 


        Here is an example that shows how to extract the pathways IDs related to
        the hsa organism::

            >>> k = Kegg()
            >>> res = k.list("pathway", organism="hsa")
            >>> pathways = [x.split()[0] for x in res.strip().split("\\n")]
            >>> len(pathways)  # as of Dec 2012
            261


        .. note:: If you set the query to a valid organism, then the second
               argument (organism is irrelevant and ignored.

        .. note:: If the query is not a database or an organism, it is supposed
            to be a valid dbentries string and the maximum number of entries is 100.

        Other examples::

            k.list("pathway")             # returns the list of reference pathways
            k.list("pathway", "hsa")      # returns the list of human pathways
            k.list("organism")            # returns the list of KEGG organisms with taxonomic classification
            k.list("hsa")                 # returns the entire list of human genes
            k.list("T01001")    # same as above
            k.list("hsa:10458+ece:Z5100") # returns the list of a human gene and an E.coli O157 gene
            k.list("cpd:C01290+gl:G00092")# returns the list of a compound entry and a glycan entry
            k.list("C01290+G00092")       # same as above 
        """
        url = self.url+"/"+"list"
        if query:
            #can be something else than a database so we can not use checkDB
            #self._checkDB(database, mode="list")
            url = url + "/" + query

        if organism:
            if organism not in self.organismIds:
                self.logging.error("""Invalid organism provided (%s). See the organisms attribute""" % organism)
                raise 
            if query not in ["pathway", "module"]:
                self.logging.error("""
    If organism is set, then the first argument
    (database) must be either 'pathway' or 'module'. You provided %s""" % query)
                raise
            url = url + "/" + organism


        res = self.request(url)
        return res

    def find(self, database, query, option=None):
        """finds entries with matching query keywords or other query data in a given database 

        :param str database: can be one of pathway, module, disease, drug,
            environ, ko, genome, compound, glycan, reaction, rpair, rclass, 
            enzyme, genes, ligand or an organism (code see :attr:`organism`
            attributes or T number)
        :param str query:
        :param str option: If option provided, database can be only 'compound' 
            or 'drug'. Option can be 'formula', 'exact_mass' or 'mol_weight'




        .. note:: Keyword search against brite is not supported. Use /list/brite to retrieve a short list.

        ::

            k.find("pathway", "Viral")    # search for pathways that contain Viral in the definition
            k.find("genes", "shiga+toxin")             # for keywords "shiga" and "toxin"
            k.find("genes", ""shiga toxin")            # for keywords "shiga toxin"
            k.find("compound", "C7H10O5", "formula")   # for chemical formula "C7H10O5"
            k.find("compound", "O5C7","formula")       # for chemical formula containing "O5" and "C7"
            k.find("compound", "174.05","exact_mass")  # for 174.045 =< exact mass < 174.055
            k.find("compound", "300-310","mol_weight") # for 300 =< molecular weight =< 310 

        """
        _valid_options = ["formula", "exact_mass", "mol_weight"]
        _valid_db_options = ["compound", "drug"]

        self._checkDB(database, mode="find") 
        url = self.url + "/find/"+ database + "/" +  query

        if option:
            if database not in _valid_db_options:
                raise ValueError("invalid database. Since option was provided, database must be in %s" % _valid_db_options)
            if option not in _valid_options:
                raise ValueError("invalid option. Must be in %s " % _valid_options)
            url +=  "/" + option

        res = self.request(url)
        return res


    def www_bget(self, entry):
        """Experimental: open the entry in a web browser

        ::

            self.www_bget("path:hsa05416")

        """
        url = "http://www.kegg.jp/dbget-bin/www_bget?" + entry
        self.logging.info(url)
        import webbrowser
        webbrowser.open(url)

    def get(self, dbentries, option=None):
        """retrieves given database entries 

        :param str dbentries: KEGG database entries involving the following 
            database: pathway, brite, module, disease, drug, environ, ko, genome
            compound, glycan,  reaction, rpair, rclass, enzyme **or** any organism 
            using the KEGG organism code (see :attr:`organisms`) or T number.
        :param str option: one of: aaseq, ntseq, mol, kcf, image

        .. note:: you can add the option at the end of dbentries in which case
            the parameter option must not be used (see example)

        ::

            self.get("cpd:C01290+gl:G00092") # retrieves a compound entry and a glycan entry
            self.get("C01290+G00092")        # same as above
            self.get("hsa:10458+ece:Z5100")  # retrieves a human gene entry and an E.coli O157 gene entry
            self.get("hsa:10458+ece:Z5100/aaseq") #retrieves amino acid sequences of a human 
                                              #gene and an E.coli O157 gene
            self.get("hsa05130/image")        # retrieves the image file of a pathway map 
            self.get("hsa05130", "image")     # same as above


        Another example here below shows how to save the image of a given pathway::

            res =  k.get("hsa05130/image")
            # same as : res =  k.get("hsa05130","image")
            f = open("test.png", "w")
            f.write(res)
            f.close()

        .. note::  The input is limited up to 10 entries. 
        """
        _valid_options = ["aaseq", "ntseq", "mol", "kcf", "image"]
        _valid_db_options = ["compound", "drug"]

        #self._checkDB(database, mode="find") 
        url = self.url + "/get/"+ dbentries

        if option:
            if option not in _valid_options:
                raise ValueError("invalid option. Must be in %s " % _valid_options)
            url +=  "/" + option

        res = self.request(url)
        return res


    def conv(self, target, source):
        """convert KEGG identifiers to/from outside identifiers 

        :param str target: the target database (e.g., a KEGG organism).
        :param str source: the source database (e.g., uniprot) or a valid
            dbentries; see below for details.

        :return: a tuple with 2 lists. The first contains the target IDs and the
            second contains the source IDs. 

        Here are the rules to set the target and source parameters.

        If the second argument is not a **dbentries**, source and target
        parameters can be of two types:

            #. gene identifiers. If the target is a KEGG Id, then the source 
               must be one of *ncbi-gi*, *ncbi-geneid* or *uniprot*.

               .. note:: source and target can be swapped.
            #. chemical substance identifiers. If the target is one of the 
               following kegg database: drug, compound, glycan then the source 
               must be one of *pubchem* or *chebi*.

               .. note:: again, source and target can be swapped

        If the second argument is a **dbentries**, it can be again of two types:

            #. gene identifiers. The database used can be one ncbi-gi,
               ncbi-geneid, uniprot or any KEGG organism
            #. chemical substance identifiers. The database used can be one of
               drug, compound, glycan, pubchem or chebi only.
        .. note:: if the second argument is a dbentries, target and dbentries
            cannot be swapped.

        Here are some examples::

            conv("eco","ncbi-geneid") # conversion from NCBI GeneID to KEGG ID for E. coli genes
            conv("eco","ncbi-geneid") # inverse of the above example
            conv("ncbi-gi","hsa:10458+ece:Z5100") #conversion from KEGG ID to NCBI GI 


        To make it clear by taking another example, you can either convert an
        entire database to another (e.g., from uniprot to Kegg Id all human gene
        IDs):: 

            kegg_ids, uniprot_ids = k.conv("hsa", "uniprot")

        or a subset by providing a valid **dbentries**::

            k.conv("hsa","up:Q9BV86+")


        .. warning:: dbentries are not check and are supposed to be correct. See :meth:`check_dbentries` to help you checking a dbentries.
        """

        # The second argument may be a source_db or a dbentries so checking
        # second argument is kind of tricky because dbentries take lots of
        # different form.

        # for now, we only check the first argument.
        # gene identifiers
        isOrg = self.isOrganism(target)
        if isOrg==False and target not in ['ncbi-gi', 'ncbi-geneid', 'uniprot', 'pubchem',
                'chebi', 'drug', 'compound', 'glycan']:
                raise ValueError("""
    Invalid syntax. target must be a KEGG ID or
    one of the allowed database. See documentation og :meth:`conv` for
    details""")

        """if target in self.organismIds:
            if source not in ['ncbi-gi', 'ncbi-geneid', 'uniprot']:
                raise ValueError("Invalid source (must be ncbi-gi, ncbi-geneid or uniprot)")
        elif target in ['ncbi-gi', 'ncbi-geneid', 'uniprot']:
            if source not in self.organismIds:
                raise ValueError("Invalid source (must be a valid KEGG organism)")

        # for chenical substance identifiers
        elif target in ['drug', 'compound', 'glycan']:
            if source not in ['chebi', 'pubchem']:
                raise ValueError("Invalid source. Must be chebi or pubchem")
        elif target in ['chebi', 'pubchem']:
            if source not in ['drug', 'compound', 'glycan']:
                raise ValueError("Invalid source. Must be drug, compound or glycan")
        else:
            self.logging.info("arguments not checked")
        """


        url = self.url + "/conv/"+ target + '/' + source

        res = self.request(url)

        try:
            t = [x.split("\t")[0] for x in res.strip().split("\n")]
            s = [x.split("\t")[1] for x in res.strip().split("\n")]
            return (t, s)
        except:
            return res


    def link(self, target, source):
        """find related entries by using database cross-references 

        :param str target: the target KEGG database or organism (see below for the list).
        :param str source: the source KEGG database or organism (see below for
            the list) or a valid dbentries involving one of the database; see
            below for details.

        The list of database is pathway, brite, module, disease, drug, environ,
            ko, genome, compound, glycan, reaction, rpair, rclass, enzyme

        ::

            k.link("pathway", "hsa")    # KEGG pathways linked from each of the human genes
	        k.link("hsa", "pathway")    # human genes linked from each of the KEGG pathways
	        k.link("pathway", "hsa:10458+ece:Z5100") 	# KEGG pathways linked
                                        # from a human gene and an E. coli O157 gene. 
        """

        self._checkDB(target, mode="link") 

        url = self.url + "/link/"+ target + '/' + source
        res = self.request(url)
        return res


    def show_pathway(self, pathId, scale=100):
        """Experimental: open a pathway in a web browser

        ::

            k.show_pathway("path:hsa05416", scale=50)

        """
        if pathId.startswith("path:"):
            pathId = pathId.split(":")[1]

        scale = int(scale/100.*100)/100. # just need 2 digits and a value in [0,1]


        url = "http://www.kegg.jp/kegg-bin/show_pathway?scale=" + str(scale)
        url += "&query=&map=" + pathId 
        self.logging.info(url)
        import webbrowser
        res = webbrowser.open(url)
        return res


    def check_dbentries(self, dbentries, checkAll=True):
        """Checks that all entries provided exist

        :param str dbentries: a dbentries list. entries are separated by the +'
            sign (e.g., "hsa:10458+ece:Z5100")
        :param bool checkAll: checks all entries (Default) or stop as soon as an
            entry is not well formed.
        :return: True if all entries are correct. False otherwise

        ::

            k = Kegg()
            k.check_dbentries("hsa:10458+ece:Z5100")


        """
        import urllib2
        entries = dbentries.split("+")
        # we do not want logging here
        debugLevel = self.debugLevel
        self.debugLevel = "CRITICAL"
        allStatus = True
        for entry in entries:
            try:
                self.get(entry)
                status = True
            # if ill-formed, an entry will raise the 404 error.
            except urllib2.HTTPError, e:
                if e.code == 404:
                    status = False
                    allStatus = False
                    if checkAll == False:
                        print entry, status 
                        return False
                else:
                    print e
                    raise
            except:
                self.debugLevel = debugLevel
                raise
            print entry, status 
        # retrive logging level
        self.debugLevel = debugLevel
        return allStatus

    # wrapper of all databases to ease access to them (buffered)

    def _get_database(self, dbname, mode=0):
        res = self.request(self.url + "/list/%s" % dbname)
        assert mode in [0,1]
        return [x.split()[mode] for x in res.split("\n") if len(x)]

    def _get_organisms(self):
        if self._organisms == None:
            self._organisms = self._get_database("organism", 1)
        return self._organisms
    organismIds = property(_get_organisms, doc="returns list of organisms")

    def _get_reactions(self):
        if self._reaction == None:
            self._reaction = self._get_database("reaction", 1)
        return self._reaction
    reactionIds = property(_get_reactions, doc="returns list of reactions")

    def _get_enzyme(self):
        if self._enzyme == None:
            self._enzyme = self._get_database("enzyme", 0)
        return self._enzyme
    enzymeIds = property(_get_enzyme, doc="returns list of enzymes")

    def _get_organisms_tnumbers(self):
        if self._organisms_tnumbers == None:
            self._organisms_tnumbers = self._get_database("organism", 0)
        return self._organisms_tnumbers
    organisms_tnumbers = property(_get_organisms_tnumbers, doc="returns list of organisms (T numbers)")

    def _get_glycans(self):
        if self._glycan == None:
            self._glycans = self._get_database("glycan", 1)
        return self._glycan
    glycanIds = property(_get_glycans, doc="returns list of glycans")

    def _get_kos(self):
        if self._ko == None:
            self._ko = self._get_database("ko", 0)
        return self._ko
    koIds = property(_get_kos, doc="returns list of ko")

    def _get_compound(self):
        if self._compound == None:
            self._compound =  self._get_database("compound", 0)
        return self._compound
    compoundIds = property(_get_compound, doc="returns list of compounds")


    def _get_drug(self):
        if self._drug == None:
            self._drug =  self._get_database("drug", 0)
        return self._drug
    drugIds = property(_get_compound, doc="returns list of drugs")

    # set the default organism used by pathways retrieval
    def _get_organism(self):
        return self._organism
    def _set_organism(self, organism):
        if organism in self.organismIds:
            self._organism = organism
            self._pathway = None
            self._ko = None
            self._glycan = None
            self._compound = None
            self._enzyme = None
            self._drug = None
            self._reaction = None

        else:
            self.logging.error("Invalid organism. Check the list in :attr:`organismIds` attribute")
            raise 
    organism = property(_get_organism, _set_organism, doc="returns the current default organism ")

    def _get_pathways(self):

        if self._organism == None:
            self.logging.warning("You must set the organism first (e.g., self.organism = 'hsa')")
            return

        if self._pathway == None:
            res = self.request(self.url + "/list/pathway/%s" % self.organism)
            orgs = [x.split()[0] for x in res.split("\n") if len(x)]
            self._pathway = orgs[:]
        return self._pathway
    pathwayIds = property(_get_pathways, doc="""returns list of pathway Ids for the default organism. 
        
    :attr:`organism` must be set.
    ::

        k = Kegg()
        k.organism = "hsa"
        k.pathwayIds

    """)


    def __str__(self):
        txt = self.info()
        return txt
